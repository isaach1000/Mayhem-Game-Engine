<title>Canvas</title>
<!DOCTYPE  html>
<html>

<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script type="text/javascript" src="bundle.js"></script>
    <script type="text/javascript" src="//localhost:35729/livereload.js">
    </script>
</head>

<body>
    <div id="game-container"></div>
    <div id="controls">
        <input type="checkbox" />Worker
        <br />
        <button>Reset</button>
        <p></p>
    </div>
    <div id="content">
        <h1 id="canvas">Canvas</h1>
        <h3 id="isaac-hier">Isaac Hier</h3>
        <h2 id="the-problem">The Problem</h2>
        <p>Before HTML5, there was no way to render custom drawings to the screen. Flash gained popularity because it provided an interface for rendering drawings and animations.
        </p>
        <h2 id="the-solution">The Solution</h2>
        <p>As the web standard has progressed, it became apparent that modern browsers could implement this technology without the use of plugins. With the release of HTML5 came the new canvas DOM element. The canvas element can render two-dimensional drawings,
            and eventually, will be relied upon to handle three-dimensional drawings as well. Although Flash is still widely used on the web, many mobile browsers have dropped support for Flash, making it a dying platform.
        </p>
        <h2 id="the-canvas-api">The Canvas API</h2>
        <p>The canvas API is simplistic. The API methods allow one to draw lines, basic shapes, and custom paths. However, there are many needed methods that are not included in the canvas API. For example, there is no method to draw a dotted line in the
            current canvas API. One must implement this method own his/ her own in order to draw dotted lines. Also, the current implementation does not help with hit testing at all. There is no built-in method to find whether or not the mouse or a polygon
            has collided with another polygon. The canvas programmer must use mathematics to calculate these collisions, while keeping performance high. A popular solution for hit-testing is to use bounding boxes. The bounding boxes are used to check
            for collisions before performing expensive calculations to determine polygon collisions (using ray-casting, etc.). Finally, various transformations can be applied to the drawing context, such as translating, scaling, and rotating. In practice,
            it proves easier to use transformation matrices to represent the various transformations. This allows the programmer to handle various different transformations when considering collisions, etc.</p>
        <h2 id="performance-considerations">Performance considerations</h2>
        <p>The canvas API is fast, but JavaScript&#39;s single-threaded environment makes handling performance imperative. Calculations and rendering can freeze the user- interface and crash the site. Therefore, careful consideration is necessary when designing
            complex games with many mathematical calculations. As Joseph Aharon explains below, we used Web Workers to prevent performance issues.</p>
        <h1 id="web-workers">Web Workers</h1>
        <h3 id="joseph-aharon">Joseph Aharon</h3>
        <h2 id="the-problem-javascript-is-limited-to-executing-its-code-within-a-single-thread-">The problem: JavaScript is limited to executing its code within a single thread.</h2>
        <p>Computer processors are built to run through and execute code one line at a time. This means that computers cannot begin new tasks before finishing their current jobs.</p>
        <p>If that’s the case, how is it that a computer can still operate quickly while running through large loads of work? The answer is multithreading. Today’s computers are built with multiple core processors that allow them to run more than one process
            at a given time. In other words, computers can execute multiple blocks of code simultaneously. This sort of multitasking is what enables computers to run multiple applications, each of which compute complicated tasks, at once.</p>
        <p>JavaScript, however, is not intrinsically able to take advantage of multi-threading. Web applications, which run on JavaScript, are therefore limited to running within a single thread. This makes the processing power of web applications weaker
            than optimal, and such applications that run long processes can freeze the user’s window. We all know how annoying that can be.</p>
        <h2 id="the-solution-web-workers-are-javascripts-that-run-in-the-background-independently-of-other-scripts-without-affecting-the-performance-of-a-page-">The solution: Web Workers are JavaScripts that run in the background, independently of other scripts, without affecting the performance of a page.</h2>
        <p>By using Web Workers, a user can click or select user interface elements while the web worker runs in the background. This allows a web browser to separate the tasks of, say, drawing an image from computing the logic behind how that image should
            be rendered. The result is a window that won’t become unresponsive and an overall smoother user experience.</p>
        <h2 id="our-demo-">Our demo:</h2>
        <p>The above version of the Pacman game is slow because there are two concurrent processes. One is using the canvas to constantly redraw the visuals which is the primary focus of the above project. The second process is the computation of the game
            logic. The game implements Dijkstra’s search algorithm to determine the shortest path from the monster to the player. This algorithm has a long runtime, and although the monster’s path came out somewhat buggy, he usually makes his way to the
            player.</p>
        <p>The above demo has rendering errors because the game is trying to run these two sophisticated processeses simultaneously. If you check the worker checkbox and press &quot;Reset&quot;, the resulting game is the same exact game, but it uses Web
            Workers to separate the two tasks. As you can see, the result is a smoother game that remains responsive to the user&#39;s input.</p>
        <h2 id="alternative-solutions-to-the-problem-">Alternative Solutions to the problem:</h2>
        <p>Web Workers is the only way to implement multithreading in web pages. One similar alternative might be to use event driven programming, or a paradigm in which the flow of the program is determined by events. In such cases, the application is divided
            into two main loops: event detection and event processing. Web applications would be able to incorporate event driven programming by using a framework such as node.js.</p>
        <h2 id="tradeoffs-encountered-during-implementation-">Tradeoffs encountered during implementation:</h2>
        <p>One barrier to implementing Web Workers is that the programmer must have an understanding of multithreading and be able to separate different processes. At the same time, the programmer needs to be able to bring those separate processes back together
            to communicate with each other in order to make one smoothly running application.</p>
        <p>A tradeoff with workers is that it is not so simple to pass off complex data types to the worker or from the worker back to the main thread. This means that our program could not send JSON objects back and forth between the worker. To deal with
            this issue, when sending off data to the worker, our application calls a method that encodes the JSON data into an array data type of primitives. After the worker receives the array, the worker then calls another method that reconstructs the
            JSON object from the array data. In our case, the data being passed is a graph of the two dimensional layout of the game.</p>
        <p>Further reading:
            <a href="http://en.wikipedia.org/wiki/Web_worker">Web worker - Wikipedia</a>
            <a href="http://www.w3schools.com/html/html5_webworkers.asp">HTML5 Web Workers - W3Schools</a>
            <a href="http://www.html5rocks.com/en/tutorials/workers/basics/">The Basics of Web Workers - HTML5 Rocks</a>
            <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers">Using web workers - Web developer guide | MDN</a>
        </p>

    </div>
</body>

</html>
